<!doctype html><html><head><meta charset="utf-8" /><title>Preview tarjan2021zip</title><link href="/g_trees/assets/index.css" rel="stylesheet" /><script src="/g_trees/assets/pretty_previews.js" type="module" defer></script><link href="/g_trees/assets/katex.min.css" rel="stylesheet" /></head><body class="isPreview"><div id="wrapContent"><div class="csl-bib-body hangingindent">  <span style="font-variant:small-caps;">Tarjan, Robert E</span> ; <span style="font-variant:small-caps;">Levy, Caleb</span> ; <span style="font-variant:small-caps;">Timmel, Stephen</span>: Zip trees. In: <i>ACM Transactions on Algorithms (TALG)</i> vol. 17, ACM New York, NY (2021), Nr. 4, pp. 1–12<div class="bibBlurb"><p>We introduce the <em>zip tree</em>, a form of randomized binary search tree that integrates previous ideas into one practical, performant, and pleasant-to-implement package. A zip tree is a binary search tree in which each node has a numeric rank and the tree is (max)-heap-ordered with respect to ranks, with rank ties broken in favor of smaller keys. Zip trees are essentially <a href="https://link.springer.com/article/10.1007/bf01940876">treaps</a>, except that ranks are drawn from a geometric distribution instead of a uniform distribution, and we allow rank ties. These changes enable us to use fewer random bits per node.</p><p>We perform insertions and deletions by unmerging and merging paths (<em>unzipping</em> and <em>zipping</em>) rather than by doing rotations, which avoids some pointer changes and improves efficiency. The methods of zipping and unzipping take inspiration from previous top-down approaches to insertion and deletion by <a href="https://link.springer.com/article/10.1007/BF00995807">Stephenson</a>, <a href="https://dl.acm.org/doi/abs/10.1145/274787.274812">Martínez and Roura</a>, and <a href="https://link.springer.com/article/10.1007/BF02576649">Sprugnoli</a>.</p><p>From a <em>theoretical</em> standpoint, this work provides two main results. First, zip trees require only <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> bits (with high probability) to represent the largest rank in an <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-node binary search tree; previous data structures require <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> bits for the largest rank. Second, zip trees are naturally isomorphic to <a href="https://dl.acm.org/doi/abs/10.1145/78973.78977">skip lists</a>, and simplify <a href="https://dl.acm.org/doi/abs/10.1145/1233341.1233413">Dean and Jones’ mapping</a> between skip lists and binary search trees.</p></div></div></div></body></html>